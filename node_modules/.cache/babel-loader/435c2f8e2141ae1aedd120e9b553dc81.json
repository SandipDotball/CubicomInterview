{"ast":null,"code":"import { withHandlers, onWillReceiveProps, onDidUpdate, isolate, integrate } from \"reassemble\";\nexport var preventPhantomEvents = isolate(withHandlers(function () {\n  var lastTriggerTime;\n  var lastTriggerTimePerformance;\n  var timeUpdateRequested = false;\n  return {\n    requestTimeUpdate: function () {\n      return function () {\n        timeUpdateRequested = true;\n      };\n    },\n    handleTimeUpdateRequest: function () {\n      return function () {\n        if (timeUpdateRequested) {\n          lastTriggerTime = Date.now();\n\n          if (typeof performance !== \"undefined\" && typeof performance.now !== \"undefined\") {\n            lastTriggerTimePerformance = performance.now();\n          }\n\n          timeUpdateRequested = false;\n        }\n      };\n    },\n    onTransitionEnd: function (_a) {\n      var onTransitionEnd = _a.onTransitionEnd;\n      return function (e) {\n        if (!onTransitionEnd) {\n          return;\n        }\n\n        if (e.target !== e.currentTarget) {\n          onTransitionEnd(e);\n          return;\n        } // Skip transitionEnd that comes <= 10ms after (reversing) a transition.\n        // In most cases this came from the previous transition.\n\n\n        var compareWith = lastTriggerTime;\n\n        if (e.timeStamp < 1000000000000 && lastTriggerTimePerformance) {\n          compareWith = lastTriggerTimePerformance;\n        }\n\n        if (e.timeStamp - compareWith <= 10) {\n          return;\n        }\n\n        onTransitionEnd(e);\n      };\n    }\n  };\n}), onWillReceiveProps(function (_a, _b) {\n  var active = _a.active;\n  var nextActive = _b.active,\n      requestTimeUpdate = _b.requestTimeUpdate;\n\n  if (active !== nextActive) {\n    requestTimeUpdate();\n  }\n}), onDidUpdate(function (_a) {\n  var handleTimeUpdateRequest = _a.handleTimeUpdateRequest;\n  return handleTimeUpdateRequest();\n}), integrate(\"onTransitionEnd\"));","map":{"version":3,"sources":["composables/preventPhantomEvents.tsx"],"names":[],"mappings":"AACA,SAAS,YAAT,EAAuB,kBAAvB,EAA2C,WAA3C,EAAwD,OAAxD,EAAiE,SAAjE,QAAkF,YAAlF;AAYA,OAAO,IAAM,oBAAoB,GAAG,OAAO,CACzC,YAAY,CACV,YAAA;AACE,MAAI,eAAJ;AACA,MAAI,0BAAJ;AACA,MAAI,mBAAmB,GAAG,KAA1B;AACA,SAAO;AACL,IAAA,iBAAiB,EAAE,YAAA;AAAM,aAAA,YAAA;AACvB,QAAA,mBAAmB,GAAG,IAAtB;AADuB,OAAA;AAExB,KAHI;AAIL,IAAA,uBAAuB,EAAE,YAAA;AAAM,aAAA,YAAA;AAC7B,YAAI,mBAAJ,EAAyB;AACvB,UAAA,eAAe,GAAG,IAAI,CAAC,GAAL,EAAlB;;AACA,cAAI,OAAO,WAAP,KAAuB,WAAvB,IACF,OAAO,WAAW,CAAC,GAAnB,KAA2B,WAD7B,EAC0C;AACxC,YAAA,0BAA0B,GAAG,WAAW,CAAC,GAAZ,EAA7B;AACD;;AACD,UAAA,mBAAmB,GAAG,KAAtB;AACD;AAR4B,OAAA;AAS9B,KAbI;AAcL,IAAA,eAAe,EAAE,UAAC,EAAD,EAAkB;UAAhB,eAAA,GAAA,EAAA,CAAA,e;AAAqB,aAAA,UAAC,CAAD,EAAwB;AAC9D,YAAI,CAAC,eAAL,EAAsB;AAAE;AAAS;;AAEjC,YAAI,CAAC,CAAC,MAAF,KAAa,CAAC,CAAC,aAAnB,EAAkC;AAChC,UAAA,eAAe,CAAC,CAAD,CAAf;AACA;AACD,SAN6D,CAQ9D;AACA;;;AACA,YAAI,WAAW,GAAG,eAAlB;;AACA,YAAK,CAAC,CAAC,SAAF,GAAsB,aAAtB,IAAuC,0BAA5C,EAAwE;AACtE,UAAA,WAAW,GAAG,0BAAd;AACD;;AACD,YAAK,CAAC,CAAC,SAAF,GAAsB,WAAtB,IAAqC,EAA1C,EAA8C;AAC5C;AACD;;AAED,QAAA,eAAe,CAAC,CAAD,CAAf;AACD,OAnBuC;AAmBvC;AAjCI,GAAP;AAmCD,CAxCS,CAD6B,EA0CzC,kBAAkB,CAChB,UAAC,EAAD,EAAW,EAAX,EAAkD;MAAhD,MAAA,GAAA,EAAA,CAAA,M;MAAU,UAAA,GAAA,EAAA,CAAA,M;MAAoB,iBAAA,GAAA,EAAA,CAAA,iB;;AAC9B,MAAI,MAAM,KAAK,UAAf,EAA2B;AACzB,IAAA,iBAAiB;AAClB;AACF,CALe,CA1CuB,EAgDzC,WAAW,CACT,UAAC,EAAD,EAA0B;MAAxB,uBAAA,GAAA,EAAA,CAAA,uB;AAA6B,SAAA,uBAAuB,EAAvB;AAAyB,CAD/C,CAhD8B,EAmDzC,SAAS,CACP,iBADO,CAnDgC,CAApC","sourcesContent":["import { EventHandler, TransitionEvent } from \"react\";\nimport { withHandlers, onWillReceiveProps, onDidUpdate, isolate, integrate } from \"reassemble\";\n\nimport { CSSTransitionProps } from \"../csstransition\";\n\ntype PropsOut = {\n  requestTimeUpdate?: () => void;\n  handleTimeUpdateRequest?: () => void;\n  onTransitionEnd?: EventHandler<TransitionEvent<any>>;\n};\n\ntype PropsUnion = CSSTransitionProps & PropsOut;\n\nexport const preventPhantomEvents = isolate(\n  withHandlers<PropsUnion, PropsOut>(\n    () => {\n      let lastTriggerTime: any;\n      let lastTriggerTimePerformance: any;\n      let timeUpdateRequested = false;\n      return {\n        requestTimeUpdate: () => () => {\n          timeUpdateRequested = true;\n        },\n        handleTimeUpdateRequest: () => () => {\n          if (timeUpdateRequested) {\n            lastTriggerTime = Date.now();\n            if (typeof performance !== \"undefined\" &&\n              typeof performance.now !== \"undefined\") {\n              lastTriggerTimePerformance = performance.now();\n            }\n            timeUpdateRequested = false;\n          }\n        },\n        onTransitionEnd: ({onTransitionEnd}) => (e: TransitionEvent<any>) => {\n          if (!onTransitionEnd) { return; }\n\n          if (e.target !== e.currentTarget) {\n            onTransitionEnd(e);\n            return;\n          }\n\n          // Skip transitionEnd that comes <= 10ms after (reversing) a transition.\n          // In most cases this came from the previous transition.\n          let compareWith = lastTriggerTime;\n          if ((e.timeStamp as any) < 1000000000000 && lastTriggerTimePerformance) {\n            compareWith = lastTriggerTimePerformance;\n          }\n          if ((e.timeStamp as any) - compareWith <= 10) {\n            return;\n          }\n\n          onTransitionEnd(e);\n        },\n      };\n    }),\n  onWillReceiveProps<PropsUnion>(\n    ({active}, {active: nextActive, requestTimeUpdate}) => {\n      if (active !== nextActive) {\n        requestTimeUpdate();\n      }\n    }),\n  onDidUpdate<PropsUnion>(\n    ({handleTimeUpdateRequest}) => handleTimeUpdateRequest(),\n  ),\n  integrate<keyof PropsUnion>(\n    \"onTransitionEnd\",\n  ),\n);\n"]},"metadata":{},"sourceType":"module"}