{"ast":null,"code":"/* tslint:disable: no-bitwise */\nimport { lazyLoadCallback, skipCallback } from \"./blueprint\";\nimport resolveValue from \"./utils/resolveValue\";\nimport toArray from \"./utils/toArray\";\n\nvar resolveCallbacks = function (list) {\n  return list.reduce(function (result, c) {\n    result.push.apply(result, resolveValue(c.instanceCallbacks));\n    return result;\n  }, []);\n};\n\nexport function branch(test, left, right) {\n  if (right === void 0) {\n    right = [];\n  }\n\n  var leftList = toArray(left);\n  var rightList = toArray(right);\n  return {\n    instanceCallbacks: function () {\n      var loaded = {\n        left: false,\n        right: false\n      };\n      var isTrue;\n      return [lazyLoadCallback(function (props) {\n        isTrue = test(props);\n\n        if (!loaded.left && isTrue) {\n          loaded.left = true;\n          var newCallbacks = resolveCallbacks(leftList);\n          var skip_1 = newCallbacks.length;\n          newCallbacks.unshift(skipCallback(function () {\n            return isTrue ? 0 : skip_1;\n          }));\n          return newCallbacks;\n        }\n\n        if (!loaded.right && !isTrue) {\n          loaded.right = true;\n          var newCallbacks = resolveCallbacks(rightList);\n          var skip_2 = newCallbacks.length;\n          newCallbacks.unshift(skipCallback(function () {\n            return isTrue ? skip_2 : 0;\n          }));\n          return newCallbacks;\n        }\n\n        return null;\n      })];\n    }\n  };\n}\nexport default branch;","map":{"version":3,"sources":["branch.ts"],"names":[],"mappings":"AAAA;AAEA,SAA+D,gBAA/D,EAAiF,YAAjF,QAAqG,aAArG;AAEA,OAAO,YAAP,MAAyB,sBAAzB;AACA,OAAO,OAAP,MAAoB,iBAApB;;AAEA,IAAM,gBAAgB,GAAG,UAAC,IAAD,EAA2B;AAAK,SAAA,IAAI,CAAC,MAAL,CACvD,UAAC,MAAD,EAAS,CAAT,EAAU;AACR,IAAA,MAAM,CAAC,IAAP,CAAW,KAAX,CAAA,MAAA,EAAe,YAAY,CAAC,CAAC,CAAC,iBAAH,CAA3B;AACA,WAAO,MAAP;AACD,GAJsD,EAAA,EAAA,CAAA;AAIjD,CAJR;;AAkBA,OAAM,SAAA,MAAA,CACJ,IADI,EAEJ,IAFI,EAGJ,KAHI,EAGkB;AAAtB,MAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,KAAA,GAAA,EAAA;AAAsB;;AAEtB,MAAM,QAAQ,GAAG,OAAO,CAAC,IAAD,CAAxB;AACA,MAAM,SAAS,GAAG,OAAO,CAAC,KAAD,CAAzB;AACA,SAAO;AACL,IAAA,iBAAiB,EAAE,YAAA;AACjB,UAAM,MAAM,GAAG;AAAE,QAAA,IAAI,EAAE,KAAR;AAAe,QAAA,KAAK,EAAE;AAAtB,OAAf;AACA,UAAI,MAAJ;AACA,aAAO,CACL,gBAAgB,CAAC,UAAC,KAAD,EAAM;AACrB,QAAA,MAAM,GAAG,IAAI,CAAC,KAAD,CAAb;;AACA,YAAI,CAAC,MAAM,CAAC,IAAR,IAAgB,MAApB,EAA4B;AAC1B,UAAA,MAAM,CAAC,IAAP,GAAc,IAAd;AACA,cAAM,YAAY,GAAG,gBAAgB,CAAC,QAAD,CAArC;AACA,cAAM,MAAI,GAAG,YAAY,CAAC,MAA1B;AACA,UAAA,YAAY,CAAC,OAAb,CACE,YAAY,CAAC,YAAA;AAAM,mBAAA,MAAM,GAAG,CAAH,GAAN,MAAA;AAAiB,WAAxB,CADd;AAGA,iBAAO,YAAP;AACD;;AACD,YAAI,CAAC,MAAM,CAAC,KAAR,IAAiB,CAAC,MAAtB,EAA8B;AAC5B,UAAA,MAAM,CAAC,KAAP,GAAe,IAAf;AACA,cAAM,YAAY,GAAG,gBAAgB,CAAC,SAAD,CAArC;AACA,cAAM,MAAI,GAAG,YAAY,CAAC,MAA1B;AACA,UAAA,YAAY,CAAC,OAAb,CACE,YAAY,CAAC,YAAA;AAAM,mBAAA,MAAM,GAAG,MAAH,GAAN,CAAA;AAAiB,WAAxB,CADd;AAGA,iBAAO,YAAP;AACD;;AACD,eAAO,IAAP;AACD,OArBe,CADX,CAAP;AAwBD;AA5BI,GAAP;AA8BD;AAED,eAAe,MAAf","sourcesContent":["/* tslint:disable: no-bitwise */\n\nimport { Composable, ComponentCallbacks, InstanceCallbackList, lazyLoadCallback, skipCallback } from \"./blueprint\";\nimport { Predicate } from \"./types\";\nimport resolveValue from \"./utils/resolveValue\";\nimport toArray from \"./utils/toArray\";\n\nconst resolveCallbacks = (list: ComponentCallbacks[]) => list.reduce<InstanceCallbackList>(\n  (result, c) => {\n    result.push(...resolveValue(c.instanceCallbacks));\n    return result;\n  }, []);\n\nexport function branch(\n  test: Predicate<any>,\n  left: Composable,\n  right?: Composable,\n): Composable;\n\nexport function branch<T>(\n  test: Predicate<T>,\n  left: Composable,\n  right?: Composable,\n): Composable;\n\nexport function branch<T>(\n  test: Predicate<T>,\n  left: Composable,\n  right: Composable = [],\n): Composable {\n  const leftList = toArray(left);\n  const rightList = toArray(right);\n  return {\n    instanceCallbacks: () => {\n      const loaded = { left: false, right: false };\n      let isTrue: boolean;\n      return [\n        lazyLoadCallback((props) => {\n          isTrue = test(props);\n          if (!loaded.left && isTrue) {\n            loaded.left = true;\n            const newCallbacks = resolveCallbacks(leftList);\n            const skip = newCallbacks.length;\n            newCallbacks.unshift(\n              skipCallback(() => isTrue ? 0 : skip),\n            );\n            return newCallbacks;\n          }\n          if (!loaded.right && !isTrue) {\n            loaded.right = true;\n            const newCallbacks = resolveCallbacks(rightList);\n            const skip = newCallbacks.length;\n            newCallbacks.unshift(\n              skipCallback(() => isTrue ? skip : 0),\n            );\n            return newCallbacks;\n          }\n          return null;\n        }),\n      ];\n    },\n  };\n}\n\nexport default branch;\n"]},"metadata":{},"sourceType":"module"}