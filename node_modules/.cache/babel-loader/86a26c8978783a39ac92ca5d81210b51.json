{"ast":null,"code":"var __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nimport { propsCallback } from \"./blueprint\";\nimport pick from \"./utils/pick\";\nimport shallowEqual from \"./utils/shallowEqual\";\nexport function withPropsOnChange(shouldMapOrKeys, propsMapper) {\n  var shouldMap = typeof shouldMapOrKeys === \"function\" ? shouldMapOrKeys : function (props, nextProps) {\n    return !shallowEqual(pick.apply(void 0, [props].concat(shouldMapOrKeys)), pick.apply(void 0, [nextProps].concat(shouldMapOrKeys)));\n  };\n  return {\n    instanceCallbacks: function () {\n      var previousProps;\n      var computedProps;\n      return [propsCallback(function (props) {\n        if (previousProps === undefined || shouldMap(previousProps, props)) {\n          computedProps = propsMapper(props);\n        }\n\n        previousProps = props;\n        return __assign({}, props, computedProps);\n      })];\n    }\n  };\n}\nexport default withPropsOnChange;","map":{"version":3,"sources":["withPropsOnChange.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,SAAqB,aAArB,QAA0C,aAA1C;AAEA,OAAO,IAAP,MAAiB,cAAjB;AACA,OAAO,YAAP,MAAyB,sBAAzB;AAYA,OAAM,SAAA,iBAAA,CACJ,eADI,EAEJ,WAFI,EAEoC;AAExC,MAAM,SAAS,GAAG,OAAO,eAAP,KAA2B,UAA3B,GACd,eADc,GAEd,UAAC,KAAD,EAAkB,SAAlB,EAAqC;AAAK,WAAA,CAAC,YAAY,CACvD,IAAI,CAAA,KAAJ,CAAI,KAAA,CAAJ,EAAI,CAAC,KAAD,EAAM,MAAN,CAAW,eAAX,CAAJ,CADuD,EAEvD,IAAI,CAAA,KAAJ,CAAI,KAAA,CAAJ,EAAI,CAAC,SAAD,EAAU,MAAV,CAFsC,eAEtC,CAAJ,CAFuD,CAAb;AAG3C,GALH;AAMA,SAAO;AACL,IAAA,iBAAiB,EAAE,YAAA;AACjB,UAAI,aAAJ;AACA,UAAI,aAAJ;AACA,aAAO,CACL,aAAa,CAAC,UAAC,KAAD,EAAM;AAClB,YAAI,aAAa,KAAK,SAAlB,IAA+B,SAAS,CAAC,aAAD,EAAgB,KAAhB,CAA5C,EAAoE;AAClE,UAAA,aAAa,GAAG,WAAW,CAAC,KAAD,CAA3B;AACD;;AACD,QAAA,aAAa,GAAG,KAAhB;AACA,eAAM,QAAA,CAAA,EAAA,EAAM,KAAN,EAAgB,aAAhB,CAAN;AACD,OANY,CADR,CAAP;AASD;AAbI,GAAP;AAeD;AAED,eAAe,iBAAf","sourcesContent":["import { Composable, propsCallback } from \"./blueprint\";\nimport { PredicateDiff, Mapper } from \"./types\";\nimport pick from \"./utils/pick\";\nimport shallowEqual from \"./utils/shallowEqual\";\n\nexport function withPropsOnChange(\n  shouldMapOrKeys: string[] | PredicateDiff<any>,\n  propsMapper: Mapper<any, any>,\n): Composable;\n\nexport function withPropsOnChange<TPropsIn, TPropsOut>(\n  shouldMapOrKeys: Array<keyof TPropsIn> | PredicateDiff<TPropsIn>,\n  propsMapper: Mapper<TPropsIn, TPropsOut>,\n): Composable;\n\nexport function withPropsOnChange<TPropsIn, TPropsOut>(\n  shouldMapOrKeys: Array<keyof TPropsIn> | PredicateDiff<TPropsIn>,\n  propsMapper: Mapper<TPropsIn, TPropsOut>,\n): Composable {\n  const shouldMap = typeof shouldMapOrKeys === \"function\"\n    ? shouldMapOrKeys\n    : (props: TPropsIn, nextProps: TPropsIn) => !shallowEqual(\n      pick(props, ...shouldMapOrKeys),\n      pick(nextProps, ...shouldMapOrKeys),\n    );\n  return {\n    instanceCallbacks: () => {\n      let previousProps: any;\n      let computedProps: any;\n      return [\n        propsCallback((props) => {\n          if (previousProps === undefined || shouldMap(previousProps, props)) {\n            computedProps = propsMapper(props);\n          }\n          previousProps = props;\n          return { ...props, ...computedProps };\n        }),\n      ];\n    },\n  };\n}\n\nexport default withPropsOnChange;\n"]},"metadata":{},"sourceType":"module"}