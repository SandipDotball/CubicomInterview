{"ast":null,"code":"var __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nimport * as React from \"react\";\nimport { Component } from \"react\";\nimport { createBlueprint } from \"./blueprint\";\nimport getDisplayName from \"./utils/getDisplayName\";\nimport getUniqueKey from \"./utils/getUniqueKey\";\nimport isReferentiallyTransparentFunctionComponent from \"./utils/isReferentiallyTransparentFunctionComponent\";\n\nvar hasWillReceivePropsCallback = function (e) {\n  return e.kind === \"componentWillReceivePropsCallback\";\n};\n\nvar AssemblyBase = function (_super) {\n  __extends(AssemblyBase, _super);\n\n  function AssemblyBase(blueprint, target, isReferentiallyTransparent, props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.pendingDataUpdate = false;\n    _this.newestState = {};\n    _this.unmounted = false;\n    _this.newestProps = props;\n    _this.newestContext = context;\n    _this.isReferentiallyTransparent = isReferentiallyTransparent;\n    _this.target = target;\n    _this.callbackList = blueprint.instanceCallbacks();\n    _this.hasWillReceivePropsCallback = _this.callbackList.some(hasWillReceivePropsCallback);\n    _this.computed = _this.runInstanceCallbacks({\n      props: props,\n      context: context,\n      component: _this.target\n    });\n    _this.state = _this.newestState;\n    return _this;\n  }\n\n  AssemblyBase.prototype.getChildContext = function () {\n    return this.computed.childContext;\n  };\n\n  AssemblyBase.prototype.componentWillMount = function () {\n    return this.runLifeCycleCallbacks(\"componentWillMountCallback\");\n  };\n\n  AssemblyBase.prototype.componentDidMount = function () {\n    return this.runLifeCycleCallbacks(\"componentDidMountCallback\");\n  };\n\n  AssemblyBase.prototype.componentWillUnmount = function () {\n    this.unmounted = true;\n    return this.runLifeCycleCallbacks(\"componentWillUnmountCallback\");\n  };\n\n  AssemblyBase.prototype.componentWillUpdate = function () {\n    return this.runLifeCycleCallbacks(\"componentWillUpdateCallback\");\n  };\n\n  AssemblyBase.prototype.componentDidUpdate = function () {\n    return this.runLifeCycleCallbacks(\"componentDidUpdateCallback\");\n  };\n\n  AssemblyBase.prototype.componentWillReceiveProps = function (nextProps, nextContext) {\n    this.newestProps = nextProps;\n    this.newestContext = nextContext;\n    this.handleDataUpdate({\n      props: nextProps,\n      context: nextContext,\n      component: this.target\n    });\n  };\n\n  AssemblyBase.prototype.shouldComponentUpdate = function (nextProps, nextState, nextContext) {\n    if (this.state !== nextState && !this.hasWillReceivePropsCallback) {\n      // State based props was not computed before, do it now.\n      this.handleDataUpdate({\n        props: nextProps,\n        context: nextContext,\n        component: this.target\n      });\n    }\n\n    var callbacks = this.computed.lifeCycleCallbacks.shouldComponentUpdateCallback;\n\n    if (callbacks) {\n      for (var i = 0; i < callbacks.length; i++) {\n        if (!callbacks[i]()) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  AssemblyBase.prototype.render = function () {\n    var _a = this.computed,\n        Component = _a.component,\n        props = _a.props;\n\n    if (!Component) {\n      return null;\n    }\n\n    if (Component === this.target && this.isReferentiallyTransparent || isReferentiallyTransparentFunctionComponent(Component)) {\n      return Component(props);\n    }\n\n    return React.createElement(Component, __assign({}, props));\n  };\n\n  AssemblyBase.prototype.runLifeCycleCallbacks = function (name) {\n    var callbacks = this.computed.lifeCycleCallbacks[name];\n\n    if (callbacks) {\n      callbacks.forEach(function (cb) {\n        return cb();\n      });\n    }\n  };\n\n  AssemblyBase.prototype.applyStateDiff = function (stateDiff) {\n    this.newestState = __assign({}, this.newestState, stateDiff);\n  };\n\n  AssemblyBase.prototype.setStateWithLifeCycle = function (stateDiff, callback, init, startAt) {\n    if (init === void 0) {\n      init = this.defaultInit;\n    }\n\n    if (startAt === void 0) {\n      startAt = 0;\n    }\n\n    if (this.pendingDataUpdate) {\n      // we are in the middle of a data update.\n      if (!this.pendingDataUpdate.dirty || startAt < this.pendingDataUpdate.startAt) {\n        this.pendingDataUpdate.dirty = true;\n        this.pendingDataUpdate.init = init;\n        this.pendingDataUpdate.startAt = startAt;\n      }\n\n      if (callback) {\n        this.pendingDataUpdate.callbacks.push(callback);\n      }\n\n      this.applyStateDiff(stateDiff);\n    } else if (this.hasWillReceivePropsCallback) {\n      // runs callbacks with the new state which will run the `componentWillReceiveProps` lifecycle\n      this.handleDataUpdate(init, startAt, stateDiff, callback);\n    } else {\n      // state changes are batched and props will be recalculated in `shouldComponentUpdate`.\n      this.applyStateDiff(stateDiff);\n      this.setState(this.newestState, callback);\n    }\n  };\n\n  Object.defineProperty(AssemblyBase.prototype, \"defaultInit\", {\n    get: function () {\n      return {\n        props: this.newestProps,\n        context: this.newestContext,\n        component: this.target\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  AssemblyBase.prototype.handleDataUpdate = function (init, startAt, stateDiff, callback) {\n    if (init === void 0) {\n      init = this.defaultInit;\n    }\n\n    if (startAt === void 0) {\n      startAt = 0;\n    }\n\n    if (stateDiff === void 0) {\n      stateDiff = {};\n    }\n\n    if (callback === void 0) {\n      callback = null;\n    }\n\n    var oldState = this.newestState;\n\n    if (stateDiff) {\n      this.applyStateDiff(stateDiff);\n    }\n\n    this.pendingDataUpdate = {\n      callbacks: callback ? [callback] : []\n    };\n    this.computed = this.runInstanceCallbacks(init, startAt);\n    var callbacks = this.pendingDataUpdate.callbacks;\n    this.pendingDataUpdate = null;\n\n    if (this.newestState !== oldState) {\n      // Component could be unmounted because something during the lifecycle call can\n      // cause a parent component to unmount this before it completed its data update.\n      if (!this.unmounted) {\n        this.setState(this.newestState, function () {\n          return callbacks.forEach(function (cb) {\n            return cb();\n          });\n        });\n      }\n    }\n  };\n\n  AssemblyBase.prototype.runInstanceCallbacks = function (init, startAt) {\n    var _this = this;\n\n    if (startAt === void 0) {\n      startAt = 0;\n    }\n\n    var interim = __assign({}, init);\n\n    if (!interim.lifeCycleCallbacks) {\n      interim.lifeCycleCallbacks = {};\n    }\n\n    var _loop_1 = function (idx) {\n      var entry = this_1.callbackList[idx];\n\n      switch (entry.kind) {\n        case \"propsCallback\":\n          interim.props = entry.callback(interim.props, this_1.newestState, interim.context);\n          break;\n\n        case \"stateCallback\":\n          {\n            var sc_1 = entry;\n\n            if (this_1.hasWillReceivePropsCallback) {\n              sc_1.init = __assign({}, interim);\n              sc_1.startAt = idx;\n            }\n\n            if (!sc_1.called) {\n              sc_1.called = true;\n\n              var initState = function (name, value) {\n                var unique = getUniqueKey(name, _this.newestState);\n\n                _this.applyStateDiff((_a = {}, _a[unique] = value, _a));\n\n                var updater = function (val, callback) {\n                  _this.setStateWithLifeCycle((_a = {}, _a[unique] = val, _a), callback, sc_1.init, sc_1.startAt);\n\n                  var _a;\n                };\n\n                return {\n                  name: unique,\n                  updater: updater\n                };\n\n                var _a;\n              };\n\n              entry.callback(initState, interim.props, this_1.newestState, interim.context);\n            }\n          }\n          break;\n\n        case \"childContextCallback\":\n          interim.childContext = entry.callback(interim.childContext, interim.props, this_1.newestState, interim.context);\n          break;\n\n        case \"skipCallback\":\n          idx += entry.callback(interim.props, this_1.newestState, interim.context);\n          break;\n\n        case \"renderCallback\":\n          interim.component = entry.callback(interim.component, interim.props, this_1.newestState, interim.context);\n          break;\n\n        case \"lazyLoadCallback\":\n          var list = entry.callback(interim.props, this_1.newestState, interim.context);\n\n          if (list && list.length > 0) {\n            this_1.callbackList = this_1.callbackList.slice(0, idx + 1).concat(list, this_1.callbackList.slice(idx + 1));\n\n            if (!this_1.hasWillReceivePropsCallback) {\n              this_1.hasWillReceivePropsCallback = list.some(hasWillReceivePropsCallback);\n            }\n          }\n\n          break;\n\n        case \"componentWillReceivePropsCallback\":\n          {\n            var cc = entry;\n            var callback = entry.callback(interim.props, this_1.newestState, interim.context);\n\n            if (cc.called && this_1.pendingDataUpdate) {\n              // Props changed so we need to run this lifecycle.\n              callback();\n\n              if (this_1.pendingDataUpdate.dirty) {\n                // State changed during lifecycle, so we need to recalculated from an earlier position.\n                this_1.pendingDataUpdate.dirty = false;\n                return {\n                  value: this_1.runInstanceCallbacks(this_1.pendingDataUpdate.init, this_1.pendingDataUpdate.startAt)\n                };\n              }\n            } else {\n              cc.called = true;\n            }\n          }\n          break;\n\n        case \"componentWillMountCallback\":\n        case \"componentDidMountCallback\":\n        case \"componentWillUnmountCallback\":\n        case \"shouldComponentUpdateCallback\":\n        case \"componentWillUpdateCallback\":\n        case \"componentDidUpdateCallback\":\n          {\n            var hasCallbacks = interim.lifeCycleCallbacks[entry.kind] !== undefined;\n            var callback = entry.callback(interim.props, this_1.newestState, interim.context);\n            interim.lifeCycleCallbacks = __assign({}, interim.lifeCycleCallbacks, (_a = {}, _a[entry.kind] = hasCallbacks ? interim.lifeCycleCallbacks[entry.kind].concat([callback]) : [callback], _a));\n          }\n          break;\n\n        default:\n          throw new Error(\"Unknown callback entry '\" + entry.kind + \"'\");\n      }\n\n      out_idx_1 = idx;\n\n      var _a;\n    };\n\n    var this_1 = this,\n        out_idx_1;\n\n    for (var idx = startAt; idx < this.callbackList.length; idx++) {\n      var state_1 = _loop_1(idx);\n\n      idx = out_idx_1;\n      if (typeof state_1 === \"object\") return state_1.value;\n    }\n\n    return interim;\n  };\n\n  return AssemblyBase;\n}(Component);\n\nexport function assemble() {\n  var callbacks = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    callbacks[_i] = arguments[_i];\n  }\n\n  var blueprint = createBlueprint.apply(void 0, callbacks);\n  return function (target) {\n    var isReferentiallyTransparent = isReferentiallyTransparentFunctionComponent(target);\n    var targetName = getDisplayName(target);\n    var assembled = (_a = function (_super) {\n      __extends(class_1, _super);\n\n      function class_1(props, context) {\n        return _super.call(this, blueprint, target, isReferentiallyTransparent, props, context) || this;\n      }\n\n      return class_1;\n    }(AssemblyBase), _a.displayName = isReferentiallyTransparent ? targetName : \"Assembled(\" + targetName + \")\", _a);\n    blueprint.staticCallbacks.forEach(function (cb) {\n      return cb(assembled, target);\n    });\n    return assembled;\n\n    var _a;\n  };\n}\nexport default assemble;","map":{"version":3,"sources":["assemble.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport { ComponentClass, Component } from \"react\";\n\nimport { ReactComponent, ReactAnyComponent, ComponentEnhancer } from \"./types\";\nimport {\n  createBlueprint, InstanceCallbackListTypesafe, StateUpdater, LifeCycleCallbackTypes,\n  Blueprint, InstanceCallbackEntry, ComponentCallbacks,\n} from \"./blueprint\";\nimport getDisplayName from \"./utils/getDisplayName\";\nimport getUniqueKey from \"./utils/getUniqueKey\";\nimport isReferentiallyTransparentFunctionComponent from \"./utils/isReferentiallyTransparentFunctionComponent\";\n\ntype ComponentData = {\n  props: any,\n  context: any,\n  component: ReactAnyComponent,\n  childContext?: any,\n  lifeCycleCallbacks?: {[P in keyof LifeCycleCallbackTypes]: Function[]} & { [name: string]: Function[] },\n};\n\ntype StateCallbackEntry = InstanceCallbackEntry<\"stateCallback\"> & {\n  init?: ComponentData,\n  called?: boolean,\n  startAt?: number,\n};\n\ntype ComponentWillReceivePropsCallbackkEntry = InstanceCallbackEntry<\"componentWillReceivePropsCallback\"> & {\n  called?: boolean,\n};\n\ntype PendingDataUpdate = {\n  dirty?: boolean,\n  init?: ComponentData,\n  startAt?: number,\n  callbacks?: SetStateCallback[],\n};\n\ntype SetStateCallback = () => void;\n\nconst hasWillReceivePropsCallback = (e: InstanceCallbackEntry<any>) => e.kind === \"componentWillReceivePropsCallback\";\n\nclass AssemblyBase<T> extends Component<T, any> {\n  private target: ReactComponent<any> | string;\n  private isReferentiallyTransparent: boolean;\n  private callbackList: InstanceCallbackListTypesafe;\n  private hasWillReceivePropsCallback: boolean;\n  private computed: ComponentData;\n  private pendingDataUpdate: PendingDataUpdate = false;\n  private newestProps: any;\n  private newestContext: any;\n  private newestState: any = {};\n  private unmounted = false;\n\n  constructor(\n    blueprint: Blueprint,\n    target: ReactComponent<any> | string,\n    isReferentiallyTransparent: boolean,\n    props: any,\n    context: any,\n  ) {\n    super(props, context);\n    this.newestProps = props;\n    this.newestContext = context;\n    this.isReferentiallyTransparent = isReferentiallyTransparent;\n    this.target = target;\n    this.callbackList = blueprint.instanceCallbacks();\n    this.hasWillReceivePropsCallback = this.callbackList.some(hasWillReceivePropsCallback);\n    this.computed = this.runInstanceCallbacks({ props, context, component: this.target });\n    this.state = this.newestState;\n  }\n\n  public getChildContext() { return this.computed.childContext; }\n  public componentWillMount() { return this.runLifeCycleCallbacks(\"componentWillMountCallback\"); }\n  public componentDidMount() { return this.runLifeCycleCallbacks(\"componentDidMountCallback\"); }\n  public componentWillUnmount() {\n    this.unmounted = true;\n    return this.runLifeCycleCallbacks(\"componentWillUnmountCallback\");\n  }\n  public componentWillUpdate() { return this.runLifeCycleCallbacks(\"componentWillUpdateCallback\"); }\n  public componentDidUpdate() { return this.runLifeCycleCallbacks(\"componentDidUpdateCallback\"); }\n  public componentWillReceiveProps(nextProps: any, nextContext: any) {\n    this.newestProps = nextProps;\n    this.newestContext = nextContext;\n    this.handleDataUpdate({\n      props: nextProps,\n      context: nextContext,\n      component: this.target,\n    });\n  }\n\n  public shouldComponentUpdate(nextProps: any, nextState: any, nextContext: any) {\n    if (this.state !== nextState && !this.hasWillReceivePropsCallback) {\n      // State based props was not computed before, do it now.\n      this.handleDataUpdate({\n        props: nextProps,\n        context: nextContext,\n        component: this.target,\n      });\n    }\n    const callbacks = this.computed.lifeCycleCallbacks.shouldComponentUpdateCallback;\n    if (callbacks) {\n      for (let i = 0; i < callbacks.length; i++) {\n        if (!callbacks[i]()) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  public render() {\n    const {component: Component, props} = this.computed;\n    if (!Component) {\n      return null;\n    }\n    if (\n      Component === this.target && this.isReferentiallyTransparent ||\n      isReferentiallyTransparentFunctionComponent(Component)\n    ) {\n      return (Component as any)(props);\n    }\n    return <Component {...props} />;\n  }\n\n  private runLifeCycleCallbacks(name: keyof LifeCycleCallbackTypes) {\n    const callbacks = this.computed.lifeCycleCallbacks[name];\n    if (callbacks) { callbacks.forEach((cb) => cb()); }\n  }\n\n  private applyStateDiff(stateDiff: any) {\n    this.newestState = { ...this.newestState, ...stateDiff };\n  }\n\n  private setStateWithLifeCycle(\n    stateDiff: any,\n    callback: SetStateCallback,\n    init: ComponentData = this.defaultInit,\n    startAt: number = 0,\n  ) {\n    if (this.pendingDataUpdate) {\n      // we are in the middle of a data update.\n      if (!this.pendingDataUpdate.dirty || startAt < this.pendingDataUpdate.startAt) {\n        this.pendingDataUpdate.dirty = true;\n        this.pendingDataUpdate.init = init;\n        this.pendingDataUpdate.startAt = startAt;\n      }\n      if (callback) {\n        this.pendingDataUpdate.callbacks.push(callback);\n      }\n      this.applyStateDiff(stateDiff);\n    } else if (this.hasWillReceivePropsCallback) {\n      // runs callbacks with the new state which will run the `componentWillReceiveProps` lifecycle\n      this.handleDataUpdate(init, startAt, stateDiff, callback);\n    } else {\n      // state changes are batched and props will be recalculated in `shouldComponentUpdate`.\n      this.applyStateDiff(stateDiff);\n      this.setState(this.newestState, callback);\n    }\n  }\n\n  private get defaultInit(): ComponentData {\n    return {\n      props: this.newestProps,\n      context: this.newestContext,\n      component: this.target,\n    };\n  }\n\n  private handleDataUpdate(\n    init: ComponentData = this.defaultInit,\n    startAt: number = 0,\n    stateDiff: any = {},\n    callback: SetStateCallback = null,\n  ) {\n    const oldState = this.newestState;\n    if (stateDiff) {\n      this.applyStateDiff(stateDiff);\n    }\n    this.pendingDataUpdate = { callbacks: callback ? [callback] : [] };\n    this.computed = this.runInstanceCallbacks(init, startAt);\n    const callbacks = this.pendingDataUpdate.callbacks;\n    this.pendingDataUpdate = null;\n\n    if (this.newestState !== oldState) {\n      // Component could be unmounted because something during the lifecycle call can\n      // cause a parent component to unmount this before it completed its data update.\n      if (!this.unmounted) {\n        this.setState(this.newestState, () => callbacks.forEach((cb) => cb()));\n      }\n    }\n  }\n\n  private runInstanceCallbacks(init: ComponentData, startAt = 0): ComponentData {\n    const interim = { ...init };\n    if (!interim.lifeCycleCallbacks) { interim.lifeCycleCallbacks = {}; }\n    for (let idx = startAt; idx < this.callbackList.length; idx++) {\n      const entry = this.callbackList[idx];\n      switch (entry.kind) {\n        case \"propsCallback\":\n          interim.props = entry.callback(interim.props, this.newestState, interim.context);\n          break;\n        case \"stateCallback\":\n          {\n            const sc = entry as StateCallbackEntry;\n            if (this.hasWillReceivePropsCallback) {\n              sc.init = { ...interim };\n              sc.startAt = idx;\n            }\n            if (!sc.called) {\n              sc.called = true;\n              const initState = (name: string, value: any) => {\n                let unique = getUniqueKey(name, this.newestState);\n                this.applyStateDiff({ [unique]: value });\n                const updater: StateUpdater<any> = (val, callback) => {\n                  this.setStateWithLifeCycle({ [unique]: val }, callback, sc.init, sc.startAt);\n                };\n                return { name: unique, updater };\n              };\n              entry.callback(initState, interim.props, this.newestState, interim.context);\n            }\n          }\n          break;\n        case \"childContextCallback\":\n          interim.childContext = entry.callback(interim.childContext, interim.props, this.newestState, interim.context);\n          break;\n        case \"skipCallback\":\n          idx += entry.callback(interim.props, this.newestState, interim.context);\n          break;\n        case \"renderCallback\":\n          interim.component = entry.callback(interim.component, interim.props, this.newestState, interim.context);\n          break;\n        case \"lazyLoadCallback\":\n          const list = entry.callback(interim.props, this.newestState, interim.context);\n          if (list && list.length > 0) {\n            this.callbackList = [...this.callbackList.slice(0, idx + 1), ...list, ...this.callbackList.slice(idx + 1)];\n            if (!this.hasWillReceivePropsCallback) {\n              this.hasWillReceivePropsCallback = list.some(hasWillReceivePropsCallback);\n            }\n          }\n          break;\n        case \"componentWillReceivePropsCallback\":\n          {\n            const cc = entry as ComponentWillReceivePropsCallbackkEntry;\n            const callback = entry.callback(interim.props, this.newestState, interim.context);\n            if (cc.called && this.pendingDataUpdate) {\n              // Props changed so we need to run this lifecycle.\n              callback();\n              if (this.pendingDataUpdate.dirty) {\n                // State changed during lifecycle, so we need to recalculated from an earlier position.\n                this.pendingDataUpdate.dirty = false;\n                return this.runInstanceCallbacks(this.pendingDataUpdate.init, this.pendingDataUpdate.startAt);\n              }\n            } else {\n              cc.called = true;\n            }\n          }\n          break;\n        case \"componentWillMountCallback\":\n        case \"componentDidMountCallback\":\n        case \"componentWillUnmountCallback\":\n        case \"shouldComponentUpdateCallback\":\n        case \"componentWillUpdateCallback\":\n        case \"componentDidUpdateCallback\":\n          {\n            const hasCallbacks = interim.lifeCycleCallbacks[entry.kind] !== undefined;\n            const callback = entry.callback(interim.props, this.newestState, interim.context);\n            interim.lifeCycleCallbacks = {\n              ...interim.lifeCycleCallbacks,\n              [entry.kind]: hasCallbacks\n                ? [...interim.lifeCycleCallbacks[entry.kind], callback]\n                : [callback],\n            };\n          }\n          break;\n        default:\n          throw new Error(`Unknown callback entry '${(entry as any).kind}'`);\n      }\n    }\n    return interim;\n  }\n}\n\nexport function assemble(...callbacks: ComponentCallbacks[]): ComponentEnhancer<any, any>;\nexport function assemble<TInner, TOuter>(...callbacks: ComponentCallbacks[]): ComponentEnhancer<TInner, TOuter>;\nexport function assemble<TInner, TOuter>(...callbacks: ComponentCallbacks[]): ComponentEnhancer<TInner, TOuter> {\n  const blueprint = createBlueprint(...callbacks);\n  return (target: ReactComponent<TInner>) => {\n    const isReferentiallyTransparent = isReferentiallyTransparentFunctionComponent(target);\n    const targetName = getDisplayName(target);\n    const assembled: ComponentClass<TOuter> = class extends AssemblyBase<TOuter> {\n      public static displayName = isReferentiallyTransparent\n        ? targetName\n        : `Assembled(${targetName})`;\n\n      constructor(props: any, context: any) {\n        super(blueprint, target, isReferentiallyTransparent, props, context);\n      }\n    };\n    blueprint.staticCallbacks.forEach((cb) => cb(assembled, target));\n    return assembled;\n  };\n}\n\nexport default assemble;\n"]},"metadata":{},"sourceType":"module"}