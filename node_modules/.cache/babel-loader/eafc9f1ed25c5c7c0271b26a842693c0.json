{"ast":null,"code":"import parseDuration from \"./parseDuration\";\nexport function parseTransition(transition) {\n  var lastProperty = null;\n  var firstProperty = null;\n  var lastPropertyTotalDuration = -1;\n  var firstPropertyDelay = 99999999;\n  transition.split(/\\s*,\\s*(?![^\\(]*\\))/g).forEach(function (entry) {\n    var parts = entry.split(/\\s+(?![^\\(]*\\))/g);\n    var property = parts.filter(function (p) {\n      return p.match(/^[a-z\\-A-Z]+$/);\n    })[0];\n\n    var _a = parts.filter(function (p) {\n      return p.match(/^[0-9]+m?s$/);\n    }).map(function (p) {\n      return parseDuration(p);\n    }),\n        _b = _a[0],\n        duration = _b === void 0 ? 0 : _b,\n        _c = _a[1],\n        delay = _c === void 0 ? 0 : _c;\n\n    var totalDuration = duration + delay;\n\n    if (totalDuration > lastPropertyTotalDuration) {\n      lastPropertyTotalDuration = totalDuration;\n      lastProperty = {\n        property: property,\n        duration: duration,\n        delay: delay\n      };\n    }\n\n    if (delay < firstPropertyDelay) {\n      firstPropertyDelay = delay;\n      firstProperty = {\n        property: property,\n        duration: duration,\n        delay: delay\n      };\n    }\n  });\n  return [firstProperty, lastProperty];\n}\nexport default parseTransition;","map":{"version":3,"sources":["utils/parseTransition.ts"],"names":[],"mappings":"AAAA,OAAO,aAAP,MAA0B,iBAA1B;AAQA,OAAM,SAAA,eAAA,CAA0B,UAA1B,EAA4C;AAChD,MAAI,YAAY,GAAoB,IAApC;AACA,MAAI,aAAa,GAAoB,IAArC;AACA,MAAI,yBAAyB,GAAG,CAAC,CAAjC;AACA,MAAI,kBAAkB,GAAG,QAAzB;AACA,EAAA,UAAU,CAAC,KAAX,CAAiB,sBAAjB,EAAyC,OAAzC,CACE,UAAC,KAAD,EAAM;AACJ,QAAM,KAAK,GAAG,KAAK,CAAC,KAAN,CAAY,kBAAZ,CAAd;AACA,QAAM,QAAQ,GAAG,KAAK,CAAC,MAAN,CAAa,UAAC,CAAD,EAAE;AAAK,aAAA,CAAC,CAAC,KAAF,CAAA,eAAA,CAAA;AAAwB,KAA5C,EAA8C,CAA9C,CAAjB;;AACM,QAAA,EAAA,GAAA,KAAA,CAAA,MAAA,CAAA,UAAA,CAAA,EAAA;AAAA,aAAA,CAAA,CAAA,KAAA,CAAA,aAAA,CAAA;AAAA,KAAA,EAAA,GAAA,CAAA,UAAA,CAAA,EAAA;AAAA,aAAA,aAAA,CAAA,CAAA,CAAA;AAAA,KAAA,CAAA;AAAA,QAAC,EAAA,GAAA,EAAA,CAAA,CAAA,CAAD;AAAA,QAAC,QAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,CAAA,GAAA,EAAD;AAAA,QAAe,EAAA,GAAA,EAAA,CAAA,CAAA,CAAf;AAAA,QAAe,KAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,CAAA,GAAA,EAAf;;AACN,QAAM,aAAa,GAAG,QAAQ,GAAG,KAAjC;;AACA,QAAI,aAAa,GAAG,yBAApB,EAA+C;AAC7C,MAAA,yBAAyB,GAAG,aAA5B;AACA,MAAA,YAAY,GAAG;AAAE,QAAA,QAAQ,EAAA,QAAV;AAAY,QAAA,QAAQ,EAAA,QAApB;AAAsB,QAAA,KAAK,EAAA;AAA3B,OAAf;AACD;;AACD,QAAI,KAAK,GAAG,kBAAZ,EAAgC;AAC9B,MAAA,kBAAkB,GAAG,KAArB;AACA,MAAA,aAAa,GAAG;AAAE,QAAA,QAAQ,EAAA,QAAV;AAAY,QAAA,QAAQ,EAAA,QAApB;AAAsB,QAAA,KAAK,EAAA;AAA3B,OAAhB;AACD;AACF,GAdH;AAgBA,SAAO,CAAC,aAAD,EAAgB,YAAhB,CAAP;AACD;AAED,eAAe,eAAf","sourcesContent":["import parseDuration from \"./parseDuration\";\n\nexport type TransitionEntry = {\n  property: string;\n  duration: number;\n  delay: number;\n};\n\nexport function parseTransition(transition: string): [TransitionEntry, TransitionEntry] {\n  let lastProperty: TransitionEntry = null;\n  let firstProperty: TransitionEntry = null;\n  let lastPropertyTotalDuration = -1;\n  let firstPropertyDelay = 99999999;\n  transition.split(/\\s*,\\s*(?![^\\(]*\\))/g).forEach(\n    (entry) => {\n      const parts = entry.split(/\\s+(?![^\\(]*\\))/g);\n      const property = parts.filter((p) => p.match(/^[a-z\\-A-Z]+$/))[0];\n      const [duration = 0, delay = 0] = parts.filter((p) => p.match(/^[0-9]+m?s$/)).map((p) => parseDuration(p));\n      const totalDuration = duration + delay;\n      if (totalDuration > lastPropertyTotalDuration) {\n        lastPropertyTotalDuration = totalDuration;\n        lastProperty = { property, duration, delay };\n      }\n      if (delay < firstPropertyDelay) {\n        firstPropertyDelay = delay;\n        firstProperty = { property, duration, delay };\n      }\n    },\n  );\n  return [firstProperty, lastProperty];\n}\n\nexport default parseTransition;\n"]},"metadata":{},"sourceType":"module"}